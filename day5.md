1:最完美的解决轮播图的方法: 
watch+$nextTick:数据监听:监听已有数据变化

Vuex当中的仓库数据bannerList（组件在使用）：
bannerList仓库数据有没有发生过变化？
一定是有的：bannerList初始值空数组，当服务器的数据返回以后，它的bannerList存储的属性值会发生变化【变为服务器返回的数据】
组件实例在使用仓库中的bannerList，组件的这个属性bannerList一定是发生过变化，watch可以监听到。


组件实例的一个方法:$nextTick
this.$nextTick(()=>{

})
nextTick官网解释:
在下次DOM更新, 循环结束之后,执行延迟回调。在 修改数据之后 立即使用这个方法，获取更新后的DOM。
注意：组件实例的$nextTick方法，在工作当中经常使用，经常结合第三方插件使用，获取更新后的DOM节点


总结:
1:Swiper插件工作的是很常用（今晚把API、基本使用方法）看看
2:组件实例的$nextTick方法。
在下次DOM更新, 循环结束之后,执行延迟回调。在 修改数据之后 立即使用这个方法，获取更新后的DOM

2:开发Floor组件
切记:仓库当中的state的数据格式,你别瞎写胡写乱写,数据格式取决于服务器返回的数据
开发Floor组件：Floor组件它被复用的（重复使用两次）

2.1:Floor组件获取mock数据，发请求的action书写在哪里?
派发action应该是在父组件(Home路由组件)的组件挂载完毕生命周期函数中书写，因为父组件需要通知Vuex发请求，父组件
获取到mock数据，通过v-for遍历 生成多个floor组件，因此达到复用作用。


3.2:父组件派发action，通知Vuex发请求，Home父组件获取仓库的数据，通过v-for遍历出多个Floor组件


3.3v-for|v-show|v-if|这些指令可以在自定义标签（组件）的身上使用




3:把首页的轮播图拆分为一个公用组件
